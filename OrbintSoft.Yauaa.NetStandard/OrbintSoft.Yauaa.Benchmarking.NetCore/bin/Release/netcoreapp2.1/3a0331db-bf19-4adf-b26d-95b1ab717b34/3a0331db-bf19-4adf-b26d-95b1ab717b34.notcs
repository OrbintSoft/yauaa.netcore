
#define RETURNS_VOID_0
#define RETURNS_VOID_1
#define RETURNS_VOID_2
#define RETURNS_VOID_3
#define RETURNS_VOID_4
#define RETURNS_VOID_5
#define RETURNS_VOID_6
#define RETURNS_VOID_7
#define RETURNS_VOID_8
#define RETURNS_VOID_9
#define RETURNS_VOID_10
#define RETURNS_VOID_11
#define RETURNS_VOID_12
#define RETURNS_VOID_13
#define RETURNS_VOID_14
#define RETURNS_VOID_15
#define RETURNS_VOID_16
#define RETURNS_VOID_17
using System;
using System.Diagnostics;
using System.Linq; // must not be removed, used by SmartParameter and SmartArgument
using System.Threading;
using System.Reflection;
using System.Runtime.CompilerServices;
using BenchmarkDotNet;
using BenchmarkDotNet.Characteristics;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Extensions;
using BenchmarkDotNet.Helpers;
using BenchmarkDotNet.Running;
using BenchmarkDotNet.Engines;
using BenchmarkDotNet.Validators;
using OrbintSoft.Yauaa.Benchmarking;



// the namespace name must be in sync with WindowsDisassembler.BuildArguments
namespace BenchmarkDotNet.Autogenerated
{
    public class UniqueProgramName // we need different name than typical "Program" to avoid problems with referencing "Program" types from benchmarked code, #691
    {
        
        public static int Main(string[] args)
        {
            // this method MUST NOT have any dependencies to BenchmarkDotNet and any other external dlls! (CoreRT is exception from this rule)
            // otherwise if LINQPad's shadow copy is enabled, we will not register for AssemblyLoading event
            // before .NET Framework tries to load it for this method
            HelpAssemblyResolving();
            return AfterAssemblyLoadingAttached(args);
        }

        private static int AfterAssemblyLoadingAttached(string[] args)
        {
            var host = new BenchmarkDotNet.Engines.ConsoleHost(Console.Out, Console.In); // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it

            // the first thing to do is to let diagnosers hook in before anything happens
            // so all jit-related diagnosers can catch first jit compilation!
            host.BeforeAnythingElse();

            try
            {
                // we are not using Runnable here in any direct way in order to avoid strong dependency Main<=>Runnable
                // which could cause the jitting/assembly loading to happen before we do anything
                // we have some jitting diagnosers and we want them to catch all the informations!!

                string benchmarkName = args.SkipWhile(arg => arg != "--benchmarkName").Skip(1).FirstOrDefault() ?? "not provided"; // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it
                int id = int.Parse(args.Last()); // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it

#if CORERT
                
#else
                Type type = typeof(UniqueProgramName).GetTypeInfo().Assembly.GetType($"BenchmarkDotNet.Autogenerated.Runnable_{id}");
                type.GetMethod("Run", BindingFlags.Public | BindingFlags.Static).Invoke(null, new object[] { host, benchmarkName });
#endif
                return 0;
            }
            catch (Exception oom) when (oom is OutOfMemoryException || oom is TargetInvocationException reflection && reflection.InnerException is OutOfMemoryException)
            {
                host.WriteLine();
                host.WriteLine("OutOfMemoryException!");
                host.WriteLine("BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects.");
                host.WriteLine("If your benchmark allocates memory and keeps it alive, you are creating a memory leak.");
                host.WriteLine("You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that.");
                host.WriteLine();
                host.WriteLine(oom.ToString());

                return -1;
            }
            catch(Exception ex)
            {
                host.WriteLine();
                host.WriteLine(ex.ToString());
                return -1;
            }
            finally
            {
                host.AfterAll();
            }
        }

        private static void HelpAssemblyResolving()
        {
#if SHADOWCOPY
            AppDomain.CurrentDomain.AssemblyResolve += (_, args) =>
            {
                const string shadowCopyFolderPath = @"";

                var guessedPath = System.IO.Path.Combine(shadowCopyFolderPath, $"{new System.Reflection.AssemblyName(args.Name).Name}.dll");

                return System.IO.File.Exists(guessedPath) ? System.Reflection.Assembly.LoadFrom(guessedPath) : null;
            };
#endif
        }
    }

        // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_0 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_0 instance = new Runnable_0(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_0()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = DirectRange1;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_0

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange1();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_0

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange1();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_0

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref DirectRange1();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_0

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                DirectRange1();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_1 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_1 instance = new Runnable_1(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_1()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SplitLRange1;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_1

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange1();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_1

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange1();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_1

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref SplitLRange1();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_1

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SplitLRange1();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_2 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_2 instance = new Runnable_2(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_2()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = DirectRange2;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_2

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange2();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_2

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange2();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_2

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref DirectRange2();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_2

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                DirectRange2();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_3 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_3 instance = new Runnable_3(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_3()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SplitLRange2;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_3

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange2();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_3

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange2();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_3

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref SplitLRange2();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_3

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SplitLRange2();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_4 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_4 instance = new Runnable_4(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_4()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = DirectRange3;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_4

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange3();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_4

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange3();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_4

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref DirectRange3();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_4

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                DirectRange3();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_5 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_5 instance = new Runnable_5(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_5()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SplitLRange3;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_5

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange3();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_5

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange3();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_5

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref SplitLRange3();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_5

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SplitLRange3();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_6 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_6 instance = new Runnable_6(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_6()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = DirectRange4;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_6

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange4();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_6

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange4();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_6

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref DirectRange4();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_6

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                DirectRange4();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_7 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_7 instance = new Runnable_7(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_7()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SplitLRange4;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_7

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange4();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_7

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange4();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_7

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref SplitLRange4();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_7

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SplitLRange4();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_8 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_8 instance = new Runnable_8(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_8()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = DirectRange5;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_8

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange5();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_8

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange5();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_8

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref DirectRange5();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_8

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                DirectRange5();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_9 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_9 instance = new Runnable_9(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_9()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SplitLRange5;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_9

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange5();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_9

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange5();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_9

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref SplitLRange5();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_9

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SplitLRange5();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_10 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_10 instance = new Runnable_10(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_10()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = DirectRange6;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_10

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange6();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_10

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange6();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_10

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref DirectRange6();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_10

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                DirectRange6();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_11 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_11 instance = new Runnable_11(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_11()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SplitLRange6;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_11

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange6();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_11

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange6();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_11

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref SplitLRange6();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_11

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SplitLRange6();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_12 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_12 instance = new Runnable_12(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_12()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = DirectRange7;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_12

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange7();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_12

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange7();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_12

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref DirectRange7();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_12

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                DirectRange7();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_13 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_13 instance = new Runnable_13(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_13()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SplitLRange7;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_13

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange7();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_13

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange7();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_13

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref SplitLRange7();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_13

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SplitLRange7();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_14 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_14 instance = new Runnable_14(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_14()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = DirectRange8;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_14

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange8();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_14

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange8();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_14

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref DirectRange8();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_14

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                DirectRange8();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_15 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_15 instance = new Runnable_15(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_15()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SplitLRange8;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_15

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange8();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_15

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange8();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_15

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref SplitLRange8();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_15

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SplitLRange8();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_16 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_16 instance = new Runnable_16(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_16()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = DirectRange9;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_16

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange9();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_16

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return DirectRange9();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_16

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref DirectRange9();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_16

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                DirectRange9();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable_17 : global::OrbintSoft.Yauaa.Benchmarking.SplitterBenchmarks
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, string benchmarkName)
        {
            Runnable_17 instance = new Runnable_17(); // do NOT change name "instance" (used in SmartParamameter)
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var errors = BenchmarkEnvironmentInfo.Validate(job);
            if (ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = false,
                Encoding = System.Text.Encoding.ASCII,
                BenchmarkName = benchmarkName
            };

            using (var engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                var results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_17()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = SplitLRange9;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private OverheadDelegate overheadDelegate;
        private WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_17

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }
        
        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange9();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_17

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return SplitLRange9();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_17

        private void OverheadActionUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref SplitLRange9();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_17

        private void OverheadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                SplitLRange9();
            }
        }
#endif
    }
}
