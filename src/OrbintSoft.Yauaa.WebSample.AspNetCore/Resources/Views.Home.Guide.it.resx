<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="How to use Yauaa for .NET Standard" xml:space="preserve">
    <value>Come usare Yauaa per .NET standard</value>
  </data>
  <data name="Introduction" xml:space="preserve">
    <value>Introduzione</value>
  </data>
  <data name="Yauaa Tutorial" xml:space="preserve">
    <value>Yauaa Tutorial</value>
  </data>
  <data name="Demo" xml:space="preserve">
    <value>Demo</value>
  </data>
  <data name="For most common devices we provide a lookup table in yaml file to identify device brand/model based on the few info available in the user agent." xml:space="preserve">
    <value>Per i dispositivi più comuni utilizziamo una tabella di lookup definita in file .yaml per identificare marca e modello del dispositivo utilizzando le poche informaini disponibili nello user agent.</value>
  </data>
  <data name="or on his Java repository on github:" xml:space="preserve">
    <value>o sul suo repository Java su github:</value>
  </data>
  <data name="Original project" xml:space="preserve">
    <value>Progetto originale</value>
  </data>
  <data name="Thanks to custom yaml definitions, you can make the library able to identify your company applications/ tools and extract your custom fields." xml:space="preserve">
    <value>Grazie a a definizioni yaml personalizzate. puoi rendere la libreria in grado di identificare le tue applicazioni e tool aziendiali con campi personalizzati.</value>
  </data>
  <data name="That makes the library very fast, flexible and easy to mantain, on the contrary the library can't extract info that are not present on user agent string without a proper mapping." xml:space="preserve">
    <value>Ciò rende la libreria molto veloce, flessibile e facile da mantenere, per contro non siamo in grado di estrarre informazioni che non sono presenti nella stringa dello user agent senza una mappatura apposita.</value>
  </data>
  <data name="The library aims to provides a reliable and extensible user agent parsing, browser and device detection." xml:space="preserve">
    <value>Lo scopo della libreria è fornire un parsing/analisi dello user agent facilmente estensibile e personalizzabile, in grado di identificare sia il browser che il dispositivo.</value>
  </data>
  <data name="The library can be easily extended thanks to yaml files and a simple syntax (we don't rely on regular expression)." xml:space="preserve">
    <value>La libreria può essere facilmente estesa grazie a file yaml e a una sintassi molto semplice (non dipendiamo da regular expression).</value>
  </data>
  <data name="The library doesn't aim to recognize every device in the world (there are several thousands), but it is able to work, analyze and extract all attributes available in the user agent." xml:space="preserve">
    <value>Lo scopo della libreria non è identificare tutti i dispositivi al mondo (ce ne sono diverse migliaia), ma è  di essere in grado di analizzare ed estrarre tutti gli attributi disponibili a partire dallo user agent.</value>
  </data>
  <data name="This is a .NET standard library that tries to parse and analyze the user agent string and extract as many relevant attributes as possible." xml:space="preserve">
    <value>Questa è una libreria scritta per .NET standard che prova ad analizzare lo user agent ed estrarre quanti più attributi possibili.</value>
  </data>
  <data name="This is a semantic analyzer, so it doesn't rely on any database (except for some very little lookup tables), that means it is able to parse and recognize every day new kind of user agents and new patterrsns without updates." xml:space="preserve">
    <value>Questo è un analizzatore semantico che non dipende da nessuna base dati (ad eccezione di alcune piccole tabelle), questo significa che è in grado di analizzare e riconoscere ogni giorno nuovi tipi di user agent e pattern senza aggiornamenti.</value>
  </data>
  <data name="This library has been built thanks to the effort of Niels Basjes, you can find more on his blog post:" xml:space="preserve">
    <value>Questa libreria è stata sviluppata grazie agli sforzi di Niels Basjes, puoi trovare più informazioni a riguardo su questo blog:</value>
  </data>
  <data name="As first step add this nuget package to your project:" xml:space="preserve">
    <value>Come primo step aggiungi questo pacchetto nuget al tuo progetto:</value>
  </data>
  <data name="Before to start I suggest to try this" xml:space="preserve">
    <value>Prima di iniziare suggerisco di provare questa</value>
  </data>
  <data name="Below you can see a sample of implementation:" xml:space="preserve">
    <value>Sotto puoi vedere un esempio di implementazione:</value>
  </data>
  <data name="How to start" xml:space="preserve">
    <value>Come iniziare</value>
  </data>
  <data name="Nuget Package" xml:space="preserve">
    <value>Pacchetto Nuget</value>
  </data>
  <data name="Since the initialization of the analyzer can be very slow and you need to do just a single time, I suggest to create a singleton as support." xml:space="preserve">
    <value>Poichè l'inizializzazione dell'analyzer può essere molto lenta e ed è necessario farla solo una volta, si succegerisce creare un sigleton di supporto.</value>
  </data>
  <data name="The constructor is protected to hide the complex nature and initialization of the class, so to simplyfy the process you can take the advantage of a builder:" xml:space="preserve">
    <value>Il costruttore è protetto per nascondere l'inizializzazione e la natura complessa della classe, quindi per semplificare il processo puoi appoggiarti a un builder:</value>
  </data>
  <data name="The library targets .NET standard 2.0, so it can be used on the following frameworks (higher versions are supported):" xml:space="preserve">
    <value>Questa libreria è scritta in .NET standard 2.0, quindi può essere usata sui seguenti frameworks (versioni più alte sono supportate)</value>
  </data>
  <data name="To use the user agent analyzer you need to create an object of type UserAgentAnalyzer" xml:space="preserve">
    <value>Per usare il parser dello user agent, è necessario instanziare un oggetto di tipo UserAgentAnalyzer</value>
  </data>
  <data name="and get all parsed fields with" xml:space="preserve">
    <value>e ottenere tutti i campi parsati con:</value>
  </data>
  <data name="As example you can read in asp.net the user agent string on the client with the following code:" xml:space="preserve">
    <value>Come esempio puoi leggere in asp.net la stringa dello user agent con il seguente codice:</value>
  </data>
  <data name="Below a complete code sample:" xml:space="preserve">
    <value>Sotto un esempio di codice completo:</value>
  </data>
  <data name="But since in most comon scenario you need to check some predefined fields, like OS, browser name or version, you can take the help of some defined constants:" xml:space="preserve">
    <value>Ma poichè negli scenari più comuni, probabilmente necessiterai di controllare solo alcuni campi predefiniti, come il sistema operativo, il nome del browser o la versione, puoi appoggiarti ad alcune costanti predefinite:</value>
  </data>
  <data name="How interpret fields and values" xml:space="preserve">
    <value>Come interpretare i campi e i valori</value>
  </data>
  <data name="How to parse" xml:space="preserve">
    <value>Come parsare</value>
  </data>
  <data name="In facts you can define any custom fields to extract all info you need in Yaml files, that makes this analyzer extremly extensible and flexible" xml:space="preserve">
    <value>Di fatto puoi definire qualsiasi campo personalizzato ed estrarre tutte le informazioni di cui necessiti in file Yaml, questo rende lo User Agent estremamente estensibile e flessibile</value>
  </data>
  <data name="Using the field name you can request the value of the field and receive an object of type AgentField:" xml:space="preserve">
    <value>Usando il nome del campo puoi richiederne il valore e ricevere un oggetto di tipo AgentField:</value>
  </data>
  <data name="With GetValue() you can read the desidered value, while with GetConfidence() you get a number that shows how much is reliable the extracted field, a confidence &lt; 0 means that parsing has failed and the extracted value is not reliable." xml:space="preserve">
    <value>Con il metodo GetValue() puoi leggere il valore desiderato, mentre con GetConficence() ottieni un  numero che indica quanto il campo estratto è affidabile. Una confidenza minore di 0 significa che l'analisi è fallita e il campo estratto non è affidabile.</value>
  </data>
  <data name="Yauaa is a dynamic User Agent Analyzer that tryes to get any possible info from user agent, that means that there are no predefined fields like most of User Agent parser" xml:space="preserve">
    <value>Yauaa è un parser dello User Agent che prova ad ottenere qualsiasi informazione possibile dallo user agent, questo significa che non ci sono campi predenfiniti come la maggior parte delle librerie per parsare lo user agent</value>
  </data>
  <data name="You can get a list of alla availables field in a user agent with:" xml:space="preserve">
    <value>Puoi ottenere una lista di tutti i campi disponibili per un dato user agent con:</value>
  </data>
  <data name="You can parse the user agent simply calling" xml:space="preserve">
    <value>Puoi parsare lo user agent semplicemente chiamando:</value>
  </data>
  <data name="You can set all required configurations on the builder, and when you are ready, you just need to call the method Build();" xml:space="preserve">
    <value>Puoi impostare tutte le configurazioni richieste sul builder, e quando sei pronto, basta che chiami il metodo Build();</value>
  </data>
  <data name="Below the possible values for DeviceClass enum" xml:space="preserve">
    <value>Sotto i possibili valori per l'enum DeviceClass</value>
  </data>
  <data name="For this purpose you can take the advantage of the UserAgentClassifier class, let see an example:" xml:space="preserve">
    <value>Per questo scopo protrai utilizzare la classe UserAgentClassifier, vediamo un esempio:</value>
  </data>
  <data name="How to classify" xml:space="preserve">
    <value>Come classificare</value>
  </data>
  <data name="In a common use case you will need to classify user agents by their kind (mobile, tablet, bot, crawler, TV, etc...)" xml:space="preserve">
    <value>In un caso comune, avrai bisogno di classificare gli user agent in base alla loro tipologia (mobile, tablet, bot, crawler, TV, etc...)</value>
  </data>
</root>